/***
 *
 * This is a Java CUP Specification For CSX-lite, a Complete Set
 * of The CSX Language.
 *
 ***/

/* Preliminaries to set up and use the scanner.  */

import java_cup.runtime.*;
parser code {:
 public void syntax_error(Symbol cur_token)
     {
 	  report_error("CSX syntax error at line "+
			String.valueOf(((CSXToken)cur_token.value).linenum),
			null);
     }
:};
init with {:              :};
scan with {: return Scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal CSXIdentifierToken     IDENTIFIER;
terminal CSXIntLitToken         INTLIT;
terminal CSXCharLitToken        CHARLIT;
terminal CSXStringLitToken      STRLIT;
terminal CSXToken     		    SEMI, LPAREN, RPAREN, ASG, LBRACE, RBRACE;
terminal CSXToken     		    PLUS, MINUS, LBRACKET, GT, CAND, LT, LEQ;
terminal CSXToken               TIMES, COMMA, GEQ, SLASH, NOTEQ, RBRACKET;
terminal CSXToken               EQ, NOT, COLON, COR, MULTICOM;
terminal CSXStringLitToken      rw_CLASS, rw_IF, rw_CONST, rw_RETURN;
terminal CSXStringLitToken      rw_READ, rw_INT, rw_FALSE, rw_ELSE, rw_TRUE;
terminal CSXStringLitToken      rw_WRITE, rw_BOOL, rw_BREAK, rw_CONTINUE;
terminal CSXStringLitToken      rw_VOID, rw_PRINT, rw_WHILE, rw_CHAR;

/* Non terminals */
non terminal csxLiteNode     	prog;
non terminal memberDeclsNode    memberdecls;
non terminal fieldDeclsNode     fielddecls;
non terminal methodDeclsNode    methoddecls;
non terminal optionalSemiNode   optionalSemi;
non terminal methodDeclNode     methoddecl;
non terminal argDeclsNode       argdecls;
non terminal argDeclNode        argdecl;
non terminal declNode           fielddecl;
non terminal stmtsNode     	    stmts;
non terminal stmtNode	     	stmt;
non terminal typeNode           type;
non terminal argsNode           args;
non terminal readNode           readlist;
non terminal printNode          writelist;
non terminal exprNode           expr;
non terminal relationOpNode     term;
non terminal binaryOpNode		factor;
non terminal binaryOpNode	    pri;
non terminal exprNode           unary;
non terminal exprNode           unit;
non terminal nameNode           name;

/* Precedences */
precedence left         CAND, COR;
precedence nonassoc     EQ, NOTEQ, LT, LEQ, GT, GEQ;
precedence left         PLUS, MINUS;
precedence left         TIMES, SLASH;
precedence right        NOT;

/* The grammar */
start with prog;

prog         ::= rw_CLASS:c IDENTIFIER:id LBRACE:l memberdecls:m RBRACE
             {: RESULT= 
                new csxLiteNode(
                    new classNode(new identNode(id.identifierText, c.linenum, c.colnum), m, 
                    c.linenum, c.colnum)); :}
        ;

memberdecls  ::= fielddecl:f memberdecls:m
             {: RESULT= 
                new memberDeclsNode(f, m, f.linenum, f.colnum); :}
        | methoddecls:m
             {: RESULT=
                new memberDeclsNode(fieldDeclsNode.NULL, m, m.linenum, m.colnum); :}
        ;

fielddecls   ::= fielddecl:f fielddecls:fs
             {:  RESULT=
                 new fieldDeclsNode(f, fs, f.linenum, f.colnum); :}
        | 
             {:  RESULT= fieldDeclsNode.NULL; :}
        ;

methoddecls  ::= methoddecl:m methoddecls:ms
              {: RESULT=
                 new  methodDeclsNode(m, ms, m.linenum, m.colnum); :}
        |
              {: RESULT= methodDeclsNode.NULL; :}
        ;

optionalSemi ::= SEMI:s
              {: RESULT = new optionalSemiNode(sym.SEMI, s.linenum, s.colnum); :}
        |
              {: RESULT= optionalSemiNode.NULL :}
        ;

methoddecl   ::= rw_VOID:v IDENTIFIER:id LPAREN RPAREN LBRACE fielddecls:f stmts:s 
                RBRACE optionalSemi
              {: RESULT =
                 new methodDeclNode(new identNode(id.identifierText, v.linenum,
                 v.colnum), afgDeclsNode.NULL, new voidTypeNode(v.linenum, v.colnum), 
                 f, s, v.linenum, v.colnum); :}
        | rw_VOID:v IDENTIFIER:id LPAREN argdecls:as RPAREN LBRACE fielddecls:f stmts:s 
                RBRACE optionalSemi
              {: RESULT = 
                 new methodDeclNode(new identNode(id.identifierText, v.linenum,
                 v.colnum), as, new voidTypeNode(v.linenum, v.colnum), f, s, 
                 v.linenum, v.colnum); :}
        | type:t IDENTIFIER:id LPAREN RPAREN LBRACE fielddecls:f stmts:s RBRACE
                optionalSemi
              {: RESULT = 
                 new methodDeclNode(new identNode(id.identifierText, t.linenum,
                 t.colnum), afgDeclsNode.NULL, t, f, s, t.linenum, t.colnum); :}
        | type:t IDENTIFIER:id LPAREN argdecls:as RPAREN LBRACE fielddecls:f stmts:s
                RBRACE optionalSemi
              {: RESULT = 
                 new methodDeclNode(new identNode(id.identifierText, t.linenum,
                 t.colnum), as, t, f, s, t.linenum, t.colnum); :}
        ;

argdecls     ::= argdecl:arg COMMA argdecls:args
              {: RESULT = 
                 new argDeclsNode(arg, args, arg.linenum, arg.colnum); :}
        | argdecl:arg
              {: RESULT = 
                 new argDeclsNode(arg, argDeclsNode.NULL, arg.linenum, arg.colnum); :}
        ;

argdecl      ::= type:t IDENTIFIER:id
              {: RESULT = 
                 new valArgDeclNode(new identNode(id.identifierText, t.linenum,
                 t.colnum), t, t.linenum, t.colnum); :}
        | type:t IDENTIFIER:id LBRACKET RBRACKET
              {: RESULT =
                  new arrayArgDeclNode(new identNode(id.identifierText,
                  t.linenum, t.colnum), t, t.linenum, t.colnum); :}
        ;

fielddecl    ::= type:t IDENTIFIER:id SEMI
              {: RESULT = 
                 new varDeclNode(new identNode(id.identifierText, t.linenum,
                 t.colnum), t, exprNode.NULL, t.linenum, t.colnum); :}
        | type:t IDENTIFIER:id ASG expr:e
              {: RESULT = 
                 new varDeclNode(new identNode(id.identifierText, t.linenum,
                 t.colnum), t, e, t.linenum, t.colnum); :}
        | type:t IDENTIFIER:id LBRACKET INTLIT:lit RBRACKET
              {: RESULT = 
                 new arrayDeclNode(new identNode(id.identifierText, t.linenum,
                 t.colnum), t, lit, t.linenum, t.colnum); :}
        | rw_CONST:c IDENTIFIER:id ASG expr:e
              {: RESULT = 
                 new constDeclNode(new identNode(id.identifierText, c.linenum,
                 c.colnum), e, c.linenum, c.colnum); :}
        ;

stmts		 ::= stmt:s1  stmts:s2
			  {: RESULT =
			     new stmtsNode(s1, s2, s1.linenum, s1.colnum); :}	
		| stmt:s1
			  {: RESULT = 
                 new stmtsNode(s1, stmtsNode.NULL, s1.linenum, s1.colnum); :}
        ;

stmt         ::= rw_IF:i LPAREN expr:e RPAREN stmt:s1
              {: RESULT = 
                 new ifThenNode(e, s1, stmtNode.NULL, i.linenum, i.colnum); :}
        | rw_IF:i LPAREN expr:e RPAREN stmt:s1 rw_ELSE stmt:s2
              {: RESULT = 
                 new ifThenNode(e, s1, s2, i.linenum, i.colnum); :}
        | rw_WHILE:w LPAREN expr:e RPAREN stmt:s
              {: RESULT = 
                 new whileNode(exprNode.NULL, e, s, w.linenum, w.colnum); :}
        | IDENTIFIER:id COLON rw_WHILE LPAREN expr:e RPAREN stmt:s
              {: RESULT = 
                 new whileNode(new identNode(id.identifierText, id.linenum,
                 id.colnum), e, s, id.linenum, id.colnum); :}
        | name:n ASG expr:e SEMI
              {: RESULT = 
                 new asgNode(n, e, n.linenum, n.colnum); :}
        | rw_READ LPAREN readlist:n RPAREN SEMI
              {: RESULT = 
                 new readNode(n, readNode.NULL, n.linenum, n.colnum); :}
        | rw_PRINT LPAREN writelist:p RPAREN SEMI
              {: RESULT = 
                 new printNode(p, printNode.NULL, p.linenum, p.colnum); :}
        | IDENTIFIER:id LPAREN RPAREN SEMI
              {: RESULT = 
                 new callNode(identNode(id.identifierText, id.linenum,
                 id.colnum), argsNode.NULL, id.linenum, id.colnum); :}
        | IDENTIFIER:id LPAREN args:a RPAREN SEMI
              {: RESULT =
                 new callNode(identNode(id.identifierText, id.linenum,
                 id.colnum), a, id.linenum, id.colnum); :}
        | rw_RETURN:r SEMI
              {: RESULT = 
                 new returnNode(exprNode.NULL, r.linenum, r.colnum); :}
        | rw_RETURN:r expr:e SEMI
              {: RESULT = 
                 new returnNode(e, r.linenum, r.colnum); :}
        | rw_BREAK:b IDENTIFIER:id
              {: RESULT = 
                 new breakNode(new identNode(id.identifierText, b.linenum,
                 b.colnum), b.linenum, b.colnum); :}
        | rw_CONTINUE:c IDENTIFIER:id
              {: RESULT = 
                 new continueNode(new identNode(id.identifierText, c.linenum,
                 c.colnum), c.linenum, c.colnum); :}
        | LBRACE:l fielddecls:f stmts:s RBRACE optionalSemi
              {: RESULT = 
                 new blockNode(f, s, l.linenum, l.colnum); :}
        ;

type         ::= rw_INT:i
              {: RESULT = new intTypeNode(i.linenum, i.colnum); :}
        | rw_CHAR:c
              {: RESULT = new charTypeNode(c.linenum, c.colnum); :}
        | rw_BOOL:b
              {: RESULT = new boolTypeNode(b.linenum, b.colnum); :}
        ;

args         ::= expr:e COMMA args:a
              {: RESULT = 
                 new argsNode(e, a, e.linenum, e.colnum); :}
        | expr:e
              {: RESULT = 
                 new argsNode(e, argsNode.NULL, e.linenum, e.colnum); :}
        ;

readlist     ::= name:n COMMA readlist:r
              {: RESULT = 
                 new readNode(n, r, n.linenum, n.colnum); :}
        | name:n
              {: RESULT = 
                 new readNode(n, readNode.NULL, n.linenum, n.colnum); :}
        ;

writelist    ::= expr:e COMMA writelist:w
              {: RESULT = 
                 new printNode(e, w, e.linenum, e.colnum); :}
        | expr:e
              {: RESULT = 
                 new printNode(e, printNode.NULL, e.linenum, e.colnum); :}
        ;

expr         ::= expr:e COR term:t
              {: RESULT = 
                 new exprNode(e, sym.COR, t, e.linenum, e.colnum); :}
        | expr:e CAND term:t
              {: RESULT = 
                 new exprNode(e, sym.CAND, t, e.linenum, e.colnum); :}
        | term:t
              {: RESULT = 
                 new exprNode(exprNode.NULL, -1, t, t.linenum, t.colnum); :}  // sym = -1
        ;

term         ::= factor:f1 LT factor:f2
              {: RESULT = new relationOpNode(f1, sym.LT, f2, f1.linenum, f1.colnum); :}
        | factor:f1 GT factor:f2
              {: RESULT = new relationOpNode(f1, sym.GT, f2, f1.linenum, f1.colnum); :}
        | factor:f1 LEQ factor:f2
              {: RESULT = new relationOpNode(f1, sym.LEQ, f2, f1.linenum, f1.colnum); :}
        | factor:f1 GEQ factor:f2
              {: RESULT = new relationOpNode(f1, sym.GEQ, f2, f1.linenum, f1.colnum); :}
        | factor:f1 EQ factor:f2
              {: RESULT = new relationOpNode(f1, sym.EQ, f2, f1.linenum, f1.colnum); :}
        | factor:f1 NOTEQ factor:f2
              {: RESULT = new relationOpNode(f1, sym.NOTEQ, f2, f1.linenum, f1.colnum); :}
        | factor:f1
              {: RESULT = new relationOpNode(f1, -1, factorNode.NULL, f1.linenum, f1.colnum); :} // sym = -1
        ;

factor       ::= factor:f PLUS pri:p
              {: RESULT = 
                 new binaryOpNode(f, sym.PLUS, p, f.linenum, f.colnum); :}
        | factor:f MINUS pri:p
              {: RESULT = 
                 new binaryOpNode(f, sym.MINUS, p, f.linenum, f.colnum); :}
        | pri:p
              {: RESULT = 
                 new binaryOpNode(p, -1, exprNode.NULL, p.linenum, p.colnum); :}
        ;

pri          ::= pri:p TIMES unary:u
              {: RESULT = 
                 new binaryOpNode(p, sym.TIMES, u, p.linenum, p.colnum); :}
        | pri:p SLASH unary:u
              {: RESULT = 
                 new binaryOpNode(p, sym.SLASH, u, p.linenum, p.colnum); :}
        | unary:u
              {: RESULT = 
                 new binaryOpNode(u, -1, exprNode.NULL, u.linenum, u.colnum); :}
        ;

unary        ::= NOT:n unary:u
              {: RESULT = 
                 new unaryOpNode(sym.NOT, u, u.linenum, u.colnum); :}
        | LPAREN:l type:t RPAREN unary:u
              {: RESULT = 
                 new castNode(t, u, l.linenum, l.colnum); :}
        | unit: n
              {: RESULT = 
                 new unaryOpNode(-1, n, n.linenum, n.colnum); :} // sym = -1
        ;

unit         ::= IDENTIFIER: id
              {: RESULT = 
                 new nameNode(new identNode(id.identifierText, id.linenum,
                 id.colnum), exprNode.NULL, id.linenum, id.colnum); :}
        | IDENTIFIER:id LBRACKET expr:e RBRACKET
              {: RESULT = 
                 new nameNode(new identNode(id.identifierText, id.linenum,
                 id.colnum), e, id.linenum, id.colnum); :}
        | IDENTIFIER:id LPAREN RPAREN
              {: RESULT = 
                 new fctCallNode(new identNode(id.identifierText,
                 id.linenum, id.colnum), argsNode.NULL, id.linenum,
                 id.colnum); :}
        | IDENTIFIER:id LPAREN args:a RPAREN
              {: RESULT = 
                 new fctCallNode(new identNode(id.identifierText,
                 id.linenum, id.colnum), a, id.linenum, id.colnum); :}
        | INTLIT:i
              {: RESULT = 
                 new intLitNode(i.intValue, i.linenum, i.colnum); :}
        | CHARLIT:i
              {: RESULT = 
                 new charLitNode(i.charValue, i.linenum, i.colnum); :}
        | STRLIT:i
              {: RESULT = 
                 new identNode(i.stringText, i.linenum, i.colnum); :}
        | rw_TRUE:t
              {: RESULT = 
                 new trueNode(t.linenum, t.colnum); :}
        | rw_FALSE:f
              {: RESULT = 
                 new falseNode(f.linenum, f.colnum); :}
        ;

name         ::= IDENTIFIER:id
              {: RESULT = 
                 new nameNode(new identNode(id.identifierText,
                 id.linenum, id.colnum), exprNode.NULL, id.linenum,
                 id.colnum); :}
        | IDENTIFIER:id LBRACKET expr:e RBRACKET
              {: RESULT = 
                 new nameNode(new identNode(id.identifierText,
                 id.linenum, id.colnum), e, id.linenum,id.colnum); :}
        ;
/*
ident		::= IDENTIFIER:i
			 {: RESULT = new identNode(i.identifierText,
						 i.linenum,i.colnum); :}	
		;
*/
